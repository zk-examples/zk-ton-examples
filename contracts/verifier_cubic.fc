#include "imports/stdlib.fc";

;; ops
const op::verify = "op::verify"c;

;; input constants (IC0 is the base term)
const slice verifier::IC0 = "8f7ec83e8c262030b5e3bf0635d08328ec1fd98025e72e36d78e47c03ab29186b7f0bb319795ae70531987752be074aa"s;
const slice verifier::IC1 = "8a83399e89cdfe9deb00acc467c2c3e7a07383d68def6bf5c3146795b0df11c8c6bf56585a068a1a50d3bd287549c5da"s;

;; vk constants
const slice verifier::vk_gamma_2 = "b2935b21a3430da5ea17f4028e3443a78ec188b6f43e11aeac4521ffdbdb5124d5c7dae9bf40314b0651bfa1bd2b08ce07a0efdd5a1b3570db9e31d5f580c89a4c92f3f46a232f33b88d7ba953c1997ea45e49ea8dab9d10770f3641dde38cf0"s;
const slice verifier::vk_delta_2 = "86208cafc8b4c214b2d728ca55a8f3a559d996d1bbf5acf9f42e650a8e21a5dda8095ccea6e796d5031058fbbf52b851170f57bcafd1461f9e1878907e73d779739b81a29b4028943d617f08297609e9b5e7909ccd1bf370a0fe2ede372fcdb2"s;
const slice verifier::vk_alpha_1 = "a865654d7629401a80edac497c4ecaaefc1226c536afac2435d98848c22e94afdbcb8a53e68f011eb2d5a17b4c75b213"s;
const slice verifier::vk_beta_2  = "8bad7d089acdcccef70c4bcd1c837305179decca03c659afe3cd61c1a9a9d74e4427fc163dcd653648051c532a1a28f013589f9fee32a37d0b9cf4a1d3c14fa4880731e96f19f255d8ee7466de0995efbf412ed536cb0975554d6ef77e052123"s;

;; public input dict settings
const int verifier::publicInputKeyLen = 32;
const int verifier::nPublic = 1;

;; error codes
const int verifier::err::public_not_present = 257;
const int verifier::err::too_many_publics = 258;
const int verifier::err::index_out_of_range = 259;
const int verifier::err::wrong_proof = 260;

;; bls intrinsics
slice bls_g1_add(slice x, slice y) asm "BLS_G1_ADD";
slice bls_g1_neg(slice x) asm "BLS_G1_NEG";
int bls_pairing(slice x1, slice y1, slice x2, slice y2, slice x3, slice y3, slice x4, slice y4, int n) asm "BLS_PAIRING";


slice bls_g1_multiexp_1(
    slice x1, int y1
    , int n
) asm "BLS_G1_MULTIEXP";

(int) groth16Verify(
    slice piA,
    slice piB,
    slice piC,
    cell pubInputs
) impure {
    int res = 0;


    ;; extract public inputs by keys 0..nPublic-1
    (slice input0, int ok0) = pubInputs~udict_delete_get?(verifier::publicInputKeyLen, 0);
    throw_unless(verifier::err::public_not_present, ok0);
    int val0 = input0~load_uint(256);

    ;; ensure the dict is now empty (no extra public inputs beyond 0..nPublic-1)
    throw_unless(verifier::err::too_many_publics, null?(pubInputs));

    ;; assemble cpub via batched MULTIEXP and summation
    slice cpub = bls_g1_multiexp_1(
        verifier::IC1, val0
        , 1
    );

    ;; add the free term IC0
    cpub = bls_g1_add(cpub, verifier::IC0);

    ;; pairing check
    slice piA_neg = bls_g1_neg(piA);
    int a = bls_pairing(
        cpub,              verifier::vk_gamma_2,
        piA_neg,          piB,
        piC,              verifier::vk_delta_2,
        verifier::vk_alpha_1, verifier::vk_beta_2,
        4
    );

    if (a == 0) {
        res = 0;
    } else {
        res = 1;
    }
    return (res);
}

(int) verifyProof(
    slice in_msg_body
) impure {
    slice piA = in_msg_body~load_ref().begin_parse();
    slice piB = in_msg_body~load_ref().begin_parse();
    slice piC = in_msg_body~load_ref().begin_parse();
    var pubInputs = in_msg_body~load_dict();

    return groth16Verify(
        piA,
        piB,
        piC,
        pubInputs
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    int op = in_msg_body~load_uint(32);

    if (op == op::verify) {
        int res = verifyProof(in_msg_body);
        throw_unless(verifier::err::wrong_proof, res == 1);
        return ();
    }
    throw(0xffff);
}

int verify(slice piA, slice piB, slice piC, slice pubInputs) method_id {
  return groth16Verify(piA, piB, piC, pubInputs~load_dict());
}
