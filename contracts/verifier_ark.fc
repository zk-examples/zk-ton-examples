#include "imports/stdlib.fc";

;; ops
const op::verify = "op::verify"c;

;; input constants (IC0 is the base term)
const slice verifier::IC0 = "afeed53d6eebfc2da813995f7f1a4a6c993b2847b32f7800a6b4fcbe0e397c6baf32aafb269e6e91b8049fde7d12d15f"s;
const slice verifier::IC1 = "81842285c4584281e58867185df524aad87efb05e4e4ed4d64829a7cb53d39530140909878bee84ac3b984b1824b79dd"s;

;; vk constants
const slice verifier::vk_gamma_2 = "84a9b33c0d55a6b74581977e92e90e65ef96614ad6d64781961a15e3a0bbd2e5ec43ccec161baed79448308eebdbbbf408a3b3fe2f021d97f8f547eb88fedb088f1784405f3d45ed381087652d8a8cfe73a6a7a2869930d7f9143e1f2d970cc2"s;
const slice verifier::vk_delta_2 = "b868baac296b0cc569e60f6da8dd2a5a858349b611d19c6e90e3e63de61ae1db6af2a6aa451e48491600b007b6540d0a08ec0c943eef6422fdb96b643f7a661f92a10fbc9a78a0fae13612bfb829e58b0e904921dffbf6658bdbcd21a73227ee"s;
const slice verifier::vk_alpha_1 = "a1886dc3d23724f1688d467c3d1ba4e23b6d0f3ed54d0ee51a9d98aacb5548e9c6fd7fe6ebe530b522de7501e802633a"s;
const slice verifier::vk_beta_2  = "891f17239d628ccbaaf34baa187c189abd34d1da3ca795ec7c53a8e64c016a9045728e1dd9ca352c927afa5c251111431731f9d0430af7e1b207f3bbbd5bb97b29e12bac9cef1e4344e9319958152d3bcfd506170b3c36d817121780e4599a43"s;

;; public input dict settings
const int verifier::publicInputKeyLen = 32;
const int verifier::nPublic = 1;

;; error codes
const int verifier::err::public_not_present = 257;
const int verifier::err::too_many_publics = 258;
const int verifier::err::index_out_of_range = 259;
const int verifier::err::wrong_proof = 260;

;; bls intrinsics
slice bls_g1_add(slice x, slice y) asm "BLS_G1_ADD";
slice bls_g1_neg(slice x) asm "BLS_G1_NEG";
int bls_pairing(slice x1, slice y1, slice x2, slice y2, slice x3, slice y3, slice x4, slice y4, int n) asm "BLS_PAIRING";


slice bls_g1_multiexp_1(
    slice x1, int y1
    , int n
) asm "BLS_G1_MULTIEXP";

(int) groth16Verify(
    slice piA,
    slice piB,
    slice piC,
    cell pubInputs
) impure {
    int res = 0;


    ;; extract public inputs by keys 0..nPublic-1
    (slice input0, int ok0) = pubInputs~udict_delete_get?(verifier::publicInputKeyLen, 0);
    throw_unless(verifier::err::public_not_present, ok0);
    int val0 = input0~load_uint(256);

    ;; ensure the dict is now empty (no extra public inputs beyond 0..nPublic-1)
    throw_unless(verifier::err::too_many_publics, null?(pubInputs));

    ;; assemble cpub via batched MULTIEXP and summation
    slice cpub = bls_g1_multiexp_1(
        verifier::IC1, val0
        , 1
    );

    ;; add the free term IC0
    cpub = bls_g1_add(cpub, verifier::IC0);

    ;; pairing check
    slice piA_neg = bls_g1_neg(piA);
    int a = bls_pairing(
        cpub,              verifier::vk_gamma_2,
        piA_neg,          piB,
        piC,              verifier::vk_delta_2,
        verifier::vk_alpha_1, verifier::vk_beta_2,
        4
    );

    if (a == 0) {
        res = 0;
    } else {
        res = 1;
    }
    return (res);
}

(int) verifyProof(
    slice in_msg_body
) impure {
    slice piA = in_msg_body~load_ref().begin_parse();
    slice piB = in_msg_body~load_ref().begin_parse();
    slice piC = in_msg_body~load_ref().begin_parse();
    var pubInputs = in_msg_body~load_dict();

    return groth16Verify(
        piA,
        piB,
        piC,
        pubInputs
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) {
        return ();
    }
    int op = in_msg_body~load_uint(32);

    if (op == op::verify) {
        int res = verifyProof(in_msg_body);
        throw_unless(verifier::err::wrong_proof, res == 1);
        return ();
    }
    throw(0xffff);
}

int verify(slice piA, slice piB, slice piC, slice pubInputs) method_id {
  return groth16Verify(piA, piB, piC, pubInputs~load_dict());
}
